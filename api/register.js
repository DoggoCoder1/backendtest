import { Pool } from 'pg';
const { google } = require('googleapis'); 

const FORBIDDEN_WORDS = [
    'fuck',
    'twat',
    'femboy',
    // Add more forbidden words here
];

/**
 * Converts a string containing common leetspeak characters to standard characters.
 * @param {string} leetString - The string to de-leetify.
 * @returns {string} The de-leetified string in lowercase.
 */
function deLeetify(leetString) {
  if (typeof leetString !== 'string') {
    return "";
  }
  let text = leetString.toLowerCase();
  // Using a map for single character replacements.
  const leetMap = {
    '4': 'a',   
    '@': 'a',   
    '3': 'e',   
    '8': 'b',   
    '1': 'l', 
    '|': 'l',   
    '0': 'o',   
    '9': 'g',   
    '6': 'g',   
    '5': 's',   
    '$': 's',   
    '7': 't',   
    '+': 't',   
    '\\/': 'v', // V-like
    '\\/\\/': 'w', // W-like
    '\\|/': 'y', // Y-like
    '2': 'z'    
  };
  
  // Handle multi-character leet first. Note the correct escaping for regex.
  // The provided leetMap's V, W, Y mappings need to be handled carefully as they contain regex-special characters.
  text = text
    .replace(/\\\/\\\/|w/g, leetMap['\\/\\/'])
    .replace(/\\\/|v/g, leetMap['\\/'])
    .replace(/\\\|\\\/|y/g, leetMap['\\|/']);

  // Handle single character replacements
  for (const [leetChar, standardChar] of Object.entries(leetMap)) {
    // Only apply for single-character leets (to avoid issues with V, W, Y placeholders)
    if (leetChar.length === 1) { 
      // Escape special characters in the leetChar for use in a RegExp constructor
      const escapedChar = leetChar.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); 
      const regex = new RegExp(escapedChar, 'g');
      text = text.replace(regex, standardChar);
    }
  }
  
  // Special case for '1' which is often 'i' or 'l'. The map already handles 'l', so we do 'i' last.
  text = text.replace(/1/g, 'i');
  
  // Remove non-alphanumeric characters (can be used as separators to bypass filters)
  text = text.replace(/[^a-z0-9]/g, '');

  return text;
}

/**
 * Checks if a username, potentially using leetspeak, contains any forbidden words.
 * @param {string} username - The username to check.
 * @returns {boolean} True if the username contains a forbidden word, false otherwise.
 */
function checkUsername(username) {
  if (typeof username !== 'string' || username.length === 0) {
    return true; // Consider empty/invalid usernames as a failure state
  }

  // 1. De-leetify and normalize the username for comparison
  const normalizedUsername = deLeetify(username);
  
  // 2. Check if the normalized username contains any forbidden words
  for (const word of FORBIDDEN_WORDS) {
    if (normalizedUsername.includes(word.toLowerCase())) {
      return true; // Found a forbidden word
    }
  }

  return false; // No forbidden words found
}

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false }
});

export default async function handler(req, res) {
  let client;
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method Not Allowed. Only POST requests are supported for registration.' });
  }

  try {
    client = await pool.connect();
    const username = req.body.username ? req.body.username.trim() : '';
    const password = req.body.password;
    
    // Basic validation
    if (!username || !password) {
      return res.status(400).json({ error: 'Username and password are required.' });
    }
    
    // Call the newly implemented checkUsername function
    if (checkUsername(username)) { // ðŸ’¡ Corrected the check to use the function
      return res.status(400).json({ error: 'Failed to sign up: Username contains forbidden words.' });
    }
    
    // Optional: Add length checks for username/password here
    // Example: if (username.length < 3 || username.length > 20) { ... }

    try {
      // Note: Storing a plain password is a MAJOR security risk. 
      // This should be storing a PASSWORD HASH (e.g., generated by bcrypt).
      await client.query('INSERT INTO users (username, password_hash) VALUES ($1, $2)', [username, password]);

      return res.status(201).json({ message: `User registered successfully.` });
    } catch (dbError) {
      if (dbError.code === '23505') {
        // PostgreSQL unique_violation error code
        return res.status(409).json({ error: 'Username already exists. Please choose a different username.' });
      }
      throw dbError; // Re-throw other database errors
    }

  } catch (err) {
    console.error('Server error during registration:', err);
    res.status(500).json({ error: 'Internal server error during registration.' });
  } finally {
    if (client) {
      client.release();
    }
  }
}